#' Check annotations from GPT
#'
#' Check GPT phenotype annotations using a several metrics.
#' @param annot GPT-generated phenotype annotations.
#' @param query_hits A named list of HPO IDs for each query,
#' generated by \link[HPOExplorer]{search_hpo}.
#' These will be used as the ground truth when trying to identify
#'  true positive annotations.
#' @param verbose Print messages.
#' @returns Named list
#'
#' @export
#' @import data.table
#' @importFrom stats na.omit
#' @examples
#' checks <- gpt_annot_check()
gpt_annot_check <- function(annot = gpt_annot_read(),
                            query_hits = search_hpo(),
                            verbose = TRUE
                            ){

  # path="~/Downloads/gpt_hpo_annotations.csv"
  pheno_count <- NULL;

  #### Proportion of HPO_IDs annotated before/after chatGPT ####
  # hpo <- get_hpo()
  # prior_ids <- unique(HPOExplorer::hpo_modifiers$hpo_id)
  # new_ids <- unique(annot$hpo_id)
  # length(new_ids)/length(prior_ids)
  # length(prior_ids)/length(hpo$id)
  # length(new_ids)/length(hpo$id)
  #### Check annotation consistency ####
  nm <- names(annot)[!grepl("hpo_name|justification|hpo_id",names(annot),
                        ignore.case = TRUE)]
  counts <- table(tolower(unlist(annot[,nm,with=FALSE])), useNA = "always")
  neg_values <- c("never","no")
  opts <- unlist(sapply(annot[,nm,with=FALSE], unique)) |> unique()
  #### Compute number of non-negative answers within each column####
  annot_mean <- annot[pheno_count>1][,lapply(.SD,function(x){
    mean(!tolower(x) %in% neg_values)
  }),.SDcols=nm,by="hpo_name"]
  #### Compute consistency within each column ####
  annot_consist <- lapply(annot_mean[,-1],
                          function(x)sum(x%in%c(0,1)/nrow(annot_mean)))
  #### Check ontology classifications #####
  annot_check <- lapply(seq(nrow(annot)), function(i){
    r <- annot[i,]
    cbind(
      r[,c("hpo_name","hpo_id")],
      lapply(stats::setNames(names(query_hits),
                             names(query_hits)),
             function(x){
               if(r$hpo_id %in% query_hits[[x]]){
                 !tolower(r[,x,with=FALSE][[1]]) %in% neg_values
               } else {
                 NA
               }
             }) |> data.table::as.data.table()
    )
  }) |> data.table::rbindlist()
  ### Proportion of rows where annotation is not NA
  checkable_rate <- sapply(
    annot_check[,names(query_hits),with=FALSE],
    function(x){sum(!is.na(x))/length(x)})
  checkable_count <- sapply(
    annot_check[,names(query_hits),with=FALSE],
    function(x){sum(!is.na(x))})
  ### Proportion of rows where the annotation was checkable and TRUE
  true_pos_rate <- sapply(
    annot_check[,names(query_hits),with=FALSE],
    function(x){sum(stats::na.omit(x)==TRUE)/length(stats::na.omit(x))})
  ### Proportion of rows where the annotation was checkable and FALSE
  false_neg_rate <- sapply(
    annot_check[,names(query_hits),with=FALSE],
    function(x){sum(stats::na.omit(x)==FALSE)/length(stats::na.omit(x))})
  #### Return ####
  return(list(
    annot=annot,
    annot_mean=annot_mean,
    annot_consist=annot_consist,
    annot_check=annot_check,
    checkable_rate=checkable_rate,
    checkable_count=checkable_count,
    true_pos_rate=true_pos_rate,
    false_neg_rate=false_neg_rate
  ))
}
